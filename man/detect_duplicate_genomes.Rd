% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/detect_duplicate_genomes.R
\name{detect_duplicate_genomes}
\alias{detect_duplicate_genomes}
\title{Compute pairwise genome similarity or distance between individuals 
to highligh potential duplicate individuals}
\usage{
detect_duplicate_genomes(data, distance.method = "manhattan",
  genome = FALSE, parallel.core = detectCores() - 1)
}
\arguments{
\item{data}{A tidy data frame object in the global environment or
a tidy data frame in wide or long format in the working directory.
\emph{How to get a tidy data frame ?}
Look into \pkg{stackr} \code{\link{tidy_genomic_data}}.}

\item{distance.method}{(character) The distance measure used inside \code{stats::dist} 
(<= 30000 markers) or \code{amap::Dist} (> 30000 markers). 
This must be one of "euclidean", "maximum", "manhattan", "canberra", "binary".
Using \code{distance.method = NULL} will not run this method.
Default: \code{distance.method = "manhattan"}. This is very fast (max 5 min)
compared to the genome similarity method.}

\item{genome}{(logical) Computes pairwise genome similarity in parallel.
The proportion of the shared genotypes is averaged across shared markers between 
each pairwise comparison. This method makes filtering easier because the 
threshold is more intuitive with the plots produced, but it's much longer 
to run, even in parallel, so better to run overnight. 
Default: \code{genome = FALSE}.}

\item{parallel.core}{(optional) The number of core for parallel computation.
Default: \code{parallel.core = detectCores()-1}.}
}
\value{
A list with potentially 8 objects: 
\code{$distance }: results of the distance method
\code{$distance.stats}: Summary statistics of the distance method
\code{$pairwise.genome.similarity}: results of the genome method
\code{$genome.stats}: Summary statistics of the genome method
\code{$violin.plot.distance}: violin plot showing the distribution of pairwise distances
\code{$jitter.plot.distance}: same info different visual with jitter plot
\code{$violin.plot.genome}: violin plot showing the distribution of pairwise genome similarities
\code{$jitter.plot.genome}: same info different visual with jitter plot

Saved in the working directory:
individuals.pairwise.dist.tsv, individuals.pairwise.distance.stats.tsv, 
individuals.pairwise.genome.similarity.tsv, individuals.pairwise.genome.stats.tsv
}
\description{
The function can compute two methods 
to highligh potential duplicate individuals (1. distance between individuals
or 2. pairwise genome similarity).
}
\examples{
\dontrun{
# to get pairwise distance only, the simplest way to run:
dup <- detect_duplicate_genomes(data = "wombat_tidy.tsv")
# This will use by defaul \\code{distance.method = "manhattan"}, 
\\code{genome = FALSE}, and all my CPU -1 as default for \\code{parallel.core}

# To view the jitter plot:
dup$jitter.plot.distance

# to view the data stats
dup.data.stats <- dup$distance.stats

# to view the data
dup.data <- dup$distance

# Based on the look of the distribution using both jitter and boxplot, 
I can filter the dataset to highlight potential duplicates: 
dup.filtered <- filter(.data = dup.data, DISTANCE < 3000000)

# To run the distance (with euclidean distance instead of the default manhattan, 
# with the genome methods:
dup <- detect_duplicate_genomes(
data = "wombat_tidy.tsv", 
distance.method = "euclidean",
genome = TRUE
)
# to view the data of the genome data
dup.data <- dup$pairwise.genome.similarity

# Based on the look of the distribution using both jitter and boxplot, 
# I can filter the dataset based on 98\% of identical genotype proportion, 
# to highlight potential duplicates: 
dup.filtered <- filter(.data = dup.data, PROP_IDENTICAL > 0.98)

# Get the list of duplicates id
dup.list.names <- data.frame(INDIVIDUALS = unique(c(dup.filtered$ID1, dup.filtered$ID2)))
}
}
\author{
Thierry Gosselin \email{thierrygosselin@icloud.com}
}

